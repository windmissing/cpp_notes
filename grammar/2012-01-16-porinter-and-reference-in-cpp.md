# 一、指针

## 1.指针的删除

### （1）删除指针后，要将指针赋为空

   使用空指针是非法的，容易使程序崩溃

   把指针赋为空是为了方便检查出错误

### （2）类的析构函数中，删除指针后，指针可以不清零。因为对象消失后，对象的成员指针就成为无法访问的指针

### （3）this指针记录的是当前对象的地址。

   this指针的创建与删除由编译器完成

## 2.指针的加减

对指针进行加减运算时，根据指针指向的类型，内存的地址会相应的改变

```c++
class A  
{  
    int x;  
};  
int main()  
{  
    A *p = new A;  
    cout<<p;  
    p++;  
    cout<<' '<<p<<endl;  
  
    int *q = new int;  
    cout<<q;  
    q++;  
    cout<<' '<<q<<endl;  
  
    double *w = new double;  
    cout<<w;  
    w++;  
    cout<<' '<<w<<endl;  
    return 0;  
}  
```

输出：

```
00741DF8 00741DFC         //类A的一个对象所占的空间是4B
00741E68 00741E6C         //一个int型变量4B
00740848 00740850          //一个double型变量所占空间是2B？？？？？？？？？？？？？？？？？？
```

## 3.几个与常量相结合的指针

|名称	|表达方式|	指针所保存的地址|	指针指向的内容
|---|---|---|---|
|常量指针|int *const p;|不可变	|可变
|指向常量的指针|const int *p;	|可变	|不可变
|指向常量的常指针|const int *const p;	|不可变	|不可变

# 二、引用

## 1.引用就是别名，如int &rnum = num;

例1：

```c++
int main()  
{  
    int a;  
    int &ra = a;  
    ra = 999;  
    cout<<"a:"<<a<<endl;  
    a = 0;  
    cout<<"ra:"<<ra<<endl;  
    cout<<&a<<' '<<&ra<<endl;  
    return 0;  
}  
```
输出：

```
a:999                                        //改变ra会导致a做同样的改变
ra:0                                           //改变a会导致ra做同样的改变
0012FF44 0012FF44           //ra和a具有相同的地址
```

1）ra是a的别名，可以说ra就是a

2）L4和L9中的&ra意义不同。

L4：说明ra是一个引用

L9：对ra取地址
 
## 2.可以定义一个对象的别名，但不能定义一个类的别名，因为类没有地址
 
## 3.定义引用时一定要同时对该引用初始化。引用如同常量，只能初始化，不能赋值。

例：

```c++
int main()  
{  
    int a;  
    int &ra = a;//正确  
  
    int b;  
    int &rb;  
    rb = b;//错误  
    return 0;  
}
```

## 4.

```c++
int *p, *q; //p和q都是指针
int *p,q; //p是指针,q是变量
```

# 三、指针与引用

## 1.指针与引用的区间

（1）指针是间接访问，因为要用*来读取地址处的数据。将指针作为函数的接收参数是间接引用的方式

引用是直接访问，因为引用是别名，不用任何符号就可以直接读取该对象的数据。将别名作为函数的接收参数是直接引用

 （2）
 
||指针|引用
|---|---|---|
|是否可以为空|可以|不可以
|是否可以初始化|可以|可以
|是否可以赋值|可以|不可以
|是否可以访问堆|可以|不可以
|不否可以改变对象|可以改变指向的对象，可以改变对象的值|不可以改变引用的对象，可以改变对象的值
 
## 2.指针与引用单独使用的举例

（1）例1：`int &r = new int; //错误，不可以直接引用来指向堆中空间`
（2）例2：

```c++
int *p = new int;  
              int &r = *p; //正确，r是通过指针p读取到的未命名int型变量的别名  
              r = 4;  
              cout << *p ; //输出4  
```

（3）例3：`int  *&r = new int; //正确`

创建一个堆中空间，定义r来作为该空间地址的引用，这样r就成了该空间地址的别名。由于引用不能作为指针来使用，所以在&r前面加个*。这样，r变成了一个指针变量，它保存的是堆中空间的地址。所以用*来访问r，*r就是访问堆中数据。用*来读取r地址处的值，*&r就是读取堆中的地址。
 
## 3.指针与引用单独使用的举例

```c++
int main()  
{  
    /*如果int申请失败->返回空指针->产生一个无用的引用 
    引用不能为空，用*读取一个无用的引用会引用系统崩溃*/  
    int *&r = new int;  
    *r = 6;  
    /*r是new int的别名，也是新空间地址的别名，用*来访问r，就是读取新空间中保存的数据*/  
    cout<<"读取新空间的地址处的值"<<*r<<endl;  
    /*r的值是新空间的地址*/  
    cout<<"输出新空间的地址"<<r<<endl;  
    /*用*r读取r的地址保存的值，则先用&取地址，再用*读取该地址的值*/  
    cout<<"读取r地址处的值"<<*&r<<endl;  
    /*r也有自身的地址*/  
    cout<<"输出r的内存地址"<<&r<<endl;  
    return 0;  
}  
```

输出：

读取新空间的地址处的值6

输出新空间的地址006A1DF8

输出r的内存地址0012FF40
